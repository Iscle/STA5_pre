//!
//!  \file 		etaldatahandler.c
//!  \brief 	<i><b> ETAL Datahandler Thread</b></i>
//!	 \details	This file implements the thread and the internal interfaces provided
//!				by ETAL to support Datapath sink functions. The user configures the sink function
//!				(or data callback) for a Datapath when he configures the Datapath through
//!				the #etal_config_datapath API. The sink is a user-provided function
//!				that ETAL calls whenever there is the need to transfer a data block to the user.
//!
//!				Since the callback is executed in the ETAL context and ETAL has no control on the
//!				duration of the callback it would be possible for a badly coded user callback to
//!				disrupt the ETAL time-critical processing. To avoid this ETAL implements a dedicated
//!				Callback Thread whose only task is to call user callbacks (this way if the callback
//!				hangs it will only affect the Callback Thread, not the whole ETAL).
//!
//!				Internally ETAL modules can request the invocation of the user callback
//!				by calling the #ETAL_datahandlerInvoke function. This function pushes an
//!				invocation request onto the Datahandler FIFO and return immediately.
//!
//!				The Datahandler FIFO is emptied asynchronously by the #ETAL_DataHandler_ThreadEntry
//!				which implements the Datahandler Thread.
//!
//!				ETAL supports a fixed number of datapaths per Receiver, one for each
//!				value defined in #EtalBcastDataType; thus given the Datapath
//!				handle ETAL is able to infer the data type, and viceversa
//!				given a data type and a Receiver handle the corresponding Datapath is uniquely
//!				identified.
//!  $Author$
//!  \author 	(original version) Raffaele Belardi
//!  $Revision$
//!  $Date$
//!
#include "osal.h"
#include "etalinternal.h"
#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_COMPONENT)
	#include "common_trace.h"
#endif
#ifdef CONFIG_ETAL_SUPPORT_CMOST_STAR
	#include"tunerdriver.h" // for CMOST_MAX_RESPONSE_LEN
	#include"tunerdriver_internal.h" // for CMOST_MAX_RESPONSE_LEN
#endif

/*****************************************************************
| defines and macros
|----------------------------------------------------------------*/
/*! \def	ETAL_DATAHANDLER_FIFO_NAME_MAX
 * 			Max size in bytes of the Datahandler FIFO names.
 * 			Used to create a unique i(per Thread) Datahandler FIFO name.
 */
#define ETAL_DATAHANDLER_FIFO_NAME_MAX  32

/*****************************************************************
| local types
|----------------------------------------------------------------*/
/*!
 * \struct	ETAL_dhMaxSizeTy
 * 			Callback FIFO elements must be dimensioned to hold the largest possible
 * 			message that can be generated by ETAL. To let the compiler calculate
 * 			this maximum size each possible message that can be sent to the
 * 			Callback Thread must be listed in the #ETAL_dhMaxSizeTy union.
 */
typedef union
{
#ifdef CONFIG_ETAL_SUPPORT_CMOST_STAR
	/*! buffer used by #ETAL_RDSRawPeriodicFunc to transfer RAW RDS data */
	tU8             RDSBufferRead[CMOST_MAX_RESPONSE_LEN];
#endif
#if defined (CONFIG_ETAL_HAVE_ETALTML) && defined (CONFIG_ETALTML_HAVE_RADIOTEXT)
	/*! buffer used to transfer Radio Information data, by:
	 *  #ETAL_CommunicationLayer_ThreadEntry_HDRADIO
	 *  #ETAL_controlPollPSDChange_HDRADIO
	 *  #ETALTML_RDScheckDecoded
	 *  #ETALTML_PADRadiotextPeriodicFunc
	 */
	EtalTextInfo   textInfo;
#endif
#if defined (CONFIG_ETAL_HAVE_ETALTML) && defined (CONFIG_ETAL_SUPPORT_CMOST_STAR)
	/*! buffer used by #ETALTML_RDScheckDecoded to transfer RDS decoded data
	 *  \remark		#ETALTML_RDScheckDecoded is listed twice because it may generate
	 *  			two different data formats
	 */
	EtalRDSData     RDSdata;
#endif
#if defined (CONFIG_ETAL_SUPPORT_DCOP_MDR)
	/*! buffer used by #ETAL_CommunicationLayer_ReceiveData_MDR (that is
	 *  the to #ETAL_CommunicationLayer_ThreadEntry_MDR thread) to transfer
	 *  #DABMW_DATACHANNEL_MSGTYPE_DECODED or #DABMW_DATACHANNEL_MSGTYPE_RAW
	 *  buffers
	 */
	tU8             dataChannel[ETAL_MAX_RESPONSE_LEN];
#endif
#if defined (CONFIG_ETAL_SUPPORT_DCOP_HDRADIO)
	/*! buffer used by #ETAL_processResponse_HDRADIO to transfer PSD data through datapath
	*/
	tU8             PSDfields[ETAL_HD_MAX_RESPONSE_LEN];
#endif
} ETAL_dhMaxSizeTy;

/*!
 * \struct	ETAL_dhFifoElemTy
 * 			Data Callback FIFO element
 */
typedef struct
{
	/*! The handle of the Datapath that originated the buffer, used to extract the
	 *  sink function
	 */
	ETAL_HANDLE      hDatapath;
	/*! The buffer containing the data to be passed to the sink function */
	ETAL_dhMaxSizeTy param;
	/*! The size in bytes of the *param* buffer */
	tU32             paramSize;
	/*! Status information on the data (e.g. error count) */
	EtalDataBlockStatusTy status;
} ETAL_dhFifoElemTy;

/*!
 * \struct	ETAL_dhStatusTy
 * 			The FIFO storage
 */
typedef struct
{
	/*! The FIFO meta-information */
	COMMON_fifoStatusTy dhFifo;
	/*! The FIFO information */
	ETAL_dhFifoElemTy dhFifoStorage[ETAL_DATAHANDLER_FIFO_ELEMENTS];
	/*! Auxiliary buffer used to pass data to the callback and release the FIFO element */
	ETAL_dhMaxSizeTy  dhStorage;
} ETAL_dhStatusTy;

/*****************************************************************
| variable definition
|----------------------------------------------------------------*/
/*!
 * \var		Etal_datahandlerStatus
 * 			The Datahandler thread private status. There is one status per
 * 			thread.
 */
static ETAL_dhStatusTy Etal_datahandlerStatus[ETAL_DATA_HANDLERS_NUM];

/***************************
 *
 * ETAL_datahandlerFifoReset
 *
 **************************/
static tSInt ETAL_datahandlerFifoReset(ETAL_dhStatusTy *pfifo, tU32 i)
{
	tChar name[ETAL_DATAHANDLER_FIFO_NAME_MAX];
	tSInt ret = OSAL_OK;

	if (OSAL_s32NPrintFormat(name, ETAL_DATAHANDLER_FIFO_NAME_MAX, "%s%u", ETAL_FIFO_DATAHANDLER_BASE_NAME, i) < 0)
	{
		ASSERT_ON_DEBUGGING(0);
		ret = OSAL_ERROR;
	}
	else
	{
		(void)OSAL_pvMemorySet((tVoid *)pfifo->dhFifoStorage, 0x00, sizeof(ETAL_dhFifoElemTy) * ETAL_DATAHANDLER_FIFO_ELEMENTS);
		(void)OSAL_pvMemorySet((tVoid *)&pfifo->dhStorage, 0x00, sizeof(ETAL_dhMaxSizeTy));
		if (COMMON_fifoInit(&pfifo->dhFifo, name, ETAL_DATAHANDLER_FIFO_ELEMENTS) != OSAL_OK)
		{
			ret = OSAL_ERROR;
		}
	}

	return ret;
}

/***************************
 *
 * ETAL_datahandlerFifoPush
 *
 **************************/
/*
 * Pushes a data packet onto the Datahandler FIFO.
 * The data pointed by <param> is copied to a local storage,
 * so <param> can be deallocated after return from this function.
 *
 * Returns:
 *  OSAL_ERROR <param_size> is larger than the max element size, or
 *             the FIFO is full. In both cases the message is discarded.
 *  OSAL_OK
 */
static tSInt ETAL_datahandlerFifoPush(ETAL_dhStatusTy *pfifo, ETAL_HANDLE hDatapath, tVoid *param, tU32 param_size, EtalDataBlockStatusTy *status)
{
	ETAL_dhFifoElemTy *elem;
	tS16 new_write_ptr;
	tSInt ret = OSAL_OK;

	if (param_size > sizeof(ETAL_dhMaxSizeTy))
	{
		ETAL_tracePrintError(TR_CLASS_APP_ETAL, "Message too long in Datahandler fifo (req %d, max %d)", param_size, sizeof(ETAL_dhMaxSizeTy));
		ret = OSAL_ERROR;
		goto exit;
	}
	COMMON_fifoGetLock(&pfifo->dhFifo);

	if (COMMON_fifoPush(&pfifo->dhFifo, &new_write_ptr) != OSAL_OK)
	{
		// FIFO overflow
		ETAL_tracePrintError(TR_CLASS_APP_ETAL, "Datahandler FIFO overflow");
		COMMON_fifoReleaseLock(&pfifo->dhFifo);
		ret = OSAL_ERROR;
		goto exit;
	}
	elem = &pfifo->dhFifoStorage[new_write_ptr];
	if ((param_size > 0) && (param != NULL))
	{
		(void)OSAL_pvMemoryCopy((tVoid *)&elem->param, (tPCVoid)param, param_size);
	}

	if (status)
	{
		(void)OSAL_pvMemoryCopy((tVoid *)&elem->status, (tPCVoid)status, sizeof(EtalDataBlockStatusTy));
		elem->status.m_isValid = TRUE;
	}
	else
	{
		(void)OSAL_pvMemorySet((tVoid *)&elem->status, 0x00, sizeof(EtalDataBlockStatusTy));
	}
	elem->hDatapath = hDatapath;
	elem->paramSize = param_size;

#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_COMPONENT)
	ETAL_traceDataPath(hDatapath, param, param_size, status);
#endif
	
	COMMON_fifoReleaseLock(&pfifo->dhFifo);

exit:
	return ret;
}

/***************************
 *
 * ETAL_datahandlerFifoPop
 *
 **************************/
static tSInt ETAL_datahandlerFifoPop(ETAL_dhStatusTy *pfifo, ETAL_HANDLE *phDatapath, ETAL_dhMaxSizeTy *param, tU32 *param_size, EtalDataBlockStatusTy *status)
{
	tSInt retval = OSAL_OK;
	tU32 size;
	ETAL_dhFifoElemTy *elem;
	tS16 new_read_ptr;

	COMMON_fifoGetLock(&pfifo->dhFifo);
	if (COMMON_fifoPop(&pfifo->dhFifo, &new_read_ptr) != OSAL_OK)
	{
		// FIFO empty condition
		COMMON_fifoReleaseLock(&pfifo->dhFifo);
		retval = OSAL_ERROR;
		goto exit;
		
	}

	elem = &pfifo->dhFifoStorage[new_read_ptr];
	size = elem->paramSize;
	if (size > 0)
	{
		if (size > sizeof(ETAL_dhMaxSizeTy))
		{
			ASSERT_ON_DEBUGGING(0);
			retval = OSAL_ERROR;
		}
		else
		{
			(void)OSAL_pvMemoryCopy((tVoid *)param, (tPCVoid)&elem->param, size);
		}
	}
	*phDatapath = elem->hDatapath;
	*param_size = size;
	(void)OSAL_pvMemoryCopy((tVoid *)status, (tPCVoid)&elem->status, sizeof(EtalDataBlockStatusTy));

	COMMON_fifoReleaseLock(&pfifo->dhFifo);

exit:
	return retval;
}

/***************************
 *
 * ETAL_datahandlerInit
 *
 **************************/
/*!
 * \brief		Initializes the Datahandler storage
 * \return		OSAL_OK
 * \callgraph
 * \callergraph
 */
tSInt ETAL_datahandlerInit(tVoid)
{
	tU32 i;
	tSInt ret = OSAL_OK;

	for (i = 0; i < ETAL_DATA_HANDLERS_NUM; i++)
	{
		if (ETAL_datahandlerFifoReset(&Etal_datahandlerStatus[i], i) != OSAL_OK)
		{
			ret = OSAL_ERROR;
			goto exit;
		}
	}

exit:
	return ret;
}

/***************************
 *
 * ETAL_datahandlerDeinit
 *
 **************************/
/*!
 * \brief		De-initializes the Datahandler storage
 * \details		Mainly destroys the semaphores created for the FIFO.
 * \return		OSAL_OK
 * \callgraph
 * \callergraph
 */
tSInt ETAL_datahandlerDeinit(tVoid)
{
	tSInt ret = OSAL_OK;
	tU32 i;
	tChar name[ETAL_DATAHANDLER_FIFO_NAME_MAX];

	for (i = 0; i < ETAL_DATA_HANDLERS_NUM; i++)
	{
		if (OSAL_s32NPrintFormat(name, ETAL_DATAHANDLER_FIFO_NAME_MAX, "%s%u", ETAL_FIFO_DATAHANDLER_BASE_NAME, i) < 0)
		{
			ASSERT_ON_DEBUGGING(0);
		}
		else
		{
			COMMON_fifoDeinit(&Etal_datahandlerStatus[i].dhFifo, name);
		}
	}

	return ret;
}

/***************************
 *
 * ETAL_datahandlerInvoke
 *
 **************************/
/*!
 * \brief		Indirectly invokes the Datapath sink
 * \details		Function called by all ETAL API functions to indirectly
 * 				invoke the Datapath sink function provided by the ETAL API user.
 * 				Puts the data into a FIFO processed by the Datahandler thread.
 * 				The Datahandler thread then calls the appropriate sink
 * 				depending on the Datapath.
 *
 * 				The *param* data buffer is copied to a Datahandler local storage
 * 				so the caller can re-use it after this function returns.
 *
 * 				The functions support multiple Datapath handlers.
 * \param[in]	handler_index - ranges 0..#ETAL_DATA_HANDLERS_NUM and indicates
 * 				                which handler to use
 * \param[in]	hDatapath     - The Datapath handle, will be used to decide which sink to invoke
 * \param[in]	param         - The data passed to the sink function
 * \param[in]	param_len     - The size in bytes of *param*
 * \param[in]	status        - The status of the data contained in *param*
 * \return		OSAL_OK    - the data was delivered without errors
 * \return		OSAL_ERROR - the FIFO is full, the data was discarded
 * \callgraph
 * \callergraph
 */
tSInt ETAL_datahandlerInvoke(tU32 handler_index, ETAL_HANDLE hDatapath, tVoid *param, tU32 param_len, EtalDataBlockStatusTy *status)
{
	tSInt ret;
	
	if (handler_index >= ETAL_DATA_HANDLERS_NUM)
	{
		ASSERT_ON_DEBUGGING(0);
		ret = OSAL_ERROR;
	}
	else if (ETAL_datahandlerFifoPush(&Etal_datahandlerStatus[handler_index], hDatapath, param, param_len, status) == OSAL_ERROR)
	{
		ret = OSAL_ERROR;
	}
	else
	{
		ret = OSAL_OK;
	}

	return ret;
}

/***************************
 *
 * ETAL_DataHandler_ThreadEntry
 *
 **************************/
/*!
 * \brief		Datahandler Thread main entry point
 * \details		Implements the Datahandler Thread. The thread endlessly tries to
 * 				pop a value from the Datahandler FIFO, invokes the sink and sleeps.
 * 				Sinks are invoked this way rather than directly from ETAL internals
 * 				to avoid locking up the whole ETAL in case of misbehaving user sink.
 *
 * 				It is possible to spawn more than one Datahandler, provided each
 * 				one is initialized with unique *thread_param* value. This feature is
 * 				implemented but not tested.
 * \remark		The function does not perform any check on the user sink duration.
 * 				It is up to the user to avoid locking up the Datahandler mechanism for too long.
 * \param[in]	thread_param - interpreted as the Datahandler index. The function
 * 				               uses this parameter to access its private storage (required
 * 				               in case more than one Datahandler thread is spawned).
 * \callgraph
 * \callergraph
 */
#ifdef CONFIG_HOST_OS_TKERNEL
tVoid ETAL_DataHandler_ThreadEntry(tSInt stacd, tPVoid thread_param)
#else
tVoid ETAL_DataHandler_ThreadEntry(tPVoid thread_param)
#endif
{
	ETAL_dhStatusTy *pstatus;
	tU32 thread_index;
	tU32 param_len;
	ETAL_HANDLE hDatapath;
	EtalSink *sinkp;
	EtalDataBlockStatusTy status;
#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_SYSTEM_MIN)
	static tBool warning_issued = FALSE;
#endif

	thread_index = (tU32)((tULong)thread_param);
	if (thread_index >= ETAL_DATA_HANDLERS_NUM)
	{
		ASSERT_ON_DEBUGGING(0);
		goto exit;
	}

	pstatus = &Etal_datahandlerStatus[thread_index];

	while (TRUE)
	{
		while (ETAL_datahandlerFifoPop(pstatus, &hDatapath, &pstatus->dhStorage, &param_len, &status) == OSAL_OK)
		{
			sinkp = ETAL_receiverDatapathGetSink(hDatapath);
			if (sinkp)
			{
				if (sinkp->m_CbProcessBlock)
				{
					sinkp->m_CbProcessBlock((tU8 *)&pstatus->dhStorage, param_len, &status, sinkp->m_context);
				}
			}
			else
			{
				/*
				 * the hDatapath is no longer valid; this may legally happen
				 * if the Datapath was removed after the ETAL_datahandlerInvoke
				 */
#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_SYSTEM_MIN)
				if (!warning_issued)
				{
					ETAL_tracePrintSysmin(TR_CLASS_APP_ETAL, "Unknown hDatapath in Datahandler");
					warning_issued = TRUE;
				}
#endif
			}
		}
		(void)OSAL_s32ThreadWait(ETAL_DATAHANDLER_THREAD_SCHEDULING);
	}

exit:
	return;
}
