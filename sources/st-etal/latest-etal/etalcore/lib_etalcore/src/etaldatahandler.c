//!
//!  \file 		etaldatahandler.c
//!  \brief 	<i><b> ETAL Datahandler Thread</b></i>
//!	 \details	This file implements the thread and the internal interfaces provided
//!				by ETAL to support Datapath sink functions. The user configures the sink function
//!				(or data callback) for a Datapath when he configures the Datapath through
//!				the #etal_config_datapath API. The sink is a user-provided function
//!				that ETAL calls whenever there is the need to transfer a data block to the user.
//!
//!				Since the callback is executed in the ETAL context and ETAL has no control on the
//!				duration of the callback it would be possible for a badly coded user callback to
//!				disrupt the ETAL time-critical processing. To avoid this ETAL implements a dedicated
//!				Callback Thread whose only task is to call user callbacks (this way if the callback
//!				hangs it will only affect the Callback Thread, not the whole ETAL).
//!
//!				Internally ETAL modules can request the invocation of the user callback
//!				by calling the #ETAL_datahandlerInvoke function. This function pushes an
//!				invocation request onto the Datahandler FIFO and return immediately.
//!
//!				The Datahandler FIFO is emptied asynchronously by the #ETAL_DataHandler_ThreadEntry
//!				which implements the Datahandler Thread.
//!
//!				ETAL supports a fixed number of datapaths per Receiver, one for each
//!				value defined in #EtalBcastDataType; thus given the Datapath
//!				handle ETAL is able to infer the data type, and viceversa
//!				given a data type and a Receiver handle the corresponding Datapath is uniquely
//!				identified.
//!  $Author$
//!  \author 	(original version) Raffaele Belardi
//!  $Revision$
//!  $Date$
//!
#include "osal.h"
#include "etalinternal.h"

#define TMP_MARGIN_SCHEDULING 	10


/*****************************************************************
| defines and macros
|----------------------------------------------------------------*/
/*! \def	ETAL_DATAHANDLER_FIFO_NAME_MAX
 * 			Max size in bytes of the Datahandler FIFO names.
 * 			Used to create a unique i(per Thread) Datahandler FIFO name.
 */
#define ETAL_DATAHANDLER_FIFO_NAME_MAX  32

#ifdef CONFIG_ETAL_CPU_IMPROVEMENT
// EVENTS

// Data To Tx event bit 0
#define	ETAL_DATAHANDLER_EVENT_TX				0

// FLAGS
#define	ETAL_DATAHANDLER_EVENT_TX_FLAG			((tU32)0x01 << ETAL_DATAHANDLER_EVENT_TX)	


// WAKEUP FULL FLAGS & MASK
#define ETAL_DATAHANDLER_EVENT_FLAGS			(ETAL_DATAHANDLER_EVENT_TX_FLAG)

#define ETAL_DATAHANDLER_EVENT_WAIT_MASK		(ETAL_DATAHANDLER_EVENT_FLAGS)

#define ETAL_DATAHANDLER_EVENT_WAIT_ALL			(0xFFFFFFFF)

#define ETAL_DATAHANDLER_EVENT_WAIT_TIME_MS		OSAL_C_TIMEOUT_FOREVER

#define ETAL_DATAHANDLER_NO_EVENT_FLAG			0x00

#endif // CONFIG_ETAL_CPU_IMPROVEMENT


/*****************************************************************
| local types
|----------------------------------------------------------------*/
/*!
 * \struct	ETAL_dhMaxSizeTy
 * 			Callback FIFO elements must be dimensioned to hold the largest possible
 * 			message that can be generated by ETAL. To let the compiler calculate
 * 			this maximum size each possible message that can be sent to the
 * 			Callback Thread must be listed in the #ETAL_dhMaxSizeTy union.
 */
typedef union
{
#ifdef CONFIG_ETAL_SUPPORT_CMOST_STAR
	/*! buffer used by #ETAL_RDSRawPeriodicFunc to transfer RAW RDS data */
	tU8             RDSBufferRead[CMOST_MAX_RESPONSE_LEN];
#endif
#if defined (CONFIG_ETAL_HAVE_ETALTML) && defined (CONFIG_ETALTML_HAVE_RADIOTEXT)
	/*! buffer used to transfer Radio Information data, by:
	 *  #ETAL_CommunicationLayer_ThreadEntry_HDRADIO
	 *  #ETAL_controlPollPSDChange_HDRADIO
	 *  #ETALTML_RDScheckDecoded
	 *  #ETALTML_PADRadiotextPeriodicFunc
	 */
	EtalTextInfo   textInfo;
#endif
#if defined (CONFIG_ETAL_HAVE_ETALTML) && defined (CONFIG_ETAL_SUPPORT_CMOST_STAR)
	/*! buffer used by #ETALTML_RDScheckDecoded to transfer RDS decoded data
	 *  \remark		#ETALTML_RDScheckDecoded is listed twice because it may generate
	 *  			two different data formats
	 */
	EtalRDSData     RDSdata;
#endif
#if defined (CONFIG_ETAL_SUPPORT_DCOP_MDR)
	/*! buffer used by #ETAL_CommunicationLayer_ReceiveData_MDR (that is
	 *  the to #ETAL_CommunicationLayer_ThreadEntry_MDR thread) to transfer
	 *  #DABMW_DATACHANNEL_MSGTYPE_DECODED or #DABMW_DATACHANNEL_MSGTYPE_RAW
	 *  buffers
	 */
	tU8             dataChannel[ETAL_MAX_RESPONSE_LEN];
#endif
#if defined (CONFIG_ETAL_SUPPORT_DCOP_HDRADIO)
	/*! buffer used by #ETAL_processResponse_HDRADIO to transfer PSD data through datapath
	*/
	tU8             PSDfields[ETAL_HD_MAX_RESPONSE_LEN];
#endif
} ETAL_dhMaxSizeTy;

/*!
 * \struct	ETAL_dhFifoElemTy
 * 			Data Callback FIFO element
 */
typedef struct
{
	/*! The handle of the Datapath that originated the buffer, used to extract the
	 *  sink function
	 */
	ETAL_HANDLE      hDatapath;
	/*! The buffer containing the data to be passed to the sink function */
	ETAL_dhMaxSizeTy param;
	/*! The size in bytes of the *param* buffer */
	tU32             paramSize;
	/*! Status information on the data (e.g. error count) */
	EtalDataBlockStatusTy status;
} ETAL_dhFifoElemTy;

/*!
 * \struct	ETAL_dhStatusTy
 * 			The FIFO storage
 */
typedef struct
{
	/*! The FIFO meta-information */
	COMMON_fifoStatusTy dhFifo;
	/*! The FIFO information */
	ETAL_dhFifoElemTy dhFifoStorage[ETAL_DATAHANDLER_FIFO_ELEMENTS];
	/*! Auxiliary buffer used to pass data to the callback and release the FIFO element */
	ETAL_dhMaxSizeTy  dhStorage;
} ETAL_dhStatusTy;

/*****************************************************************
| variable definition
|----------------------------------------------------------------*/
/*!
 * \var		Etal_datahandlerStatus
 * 			The Datahandler thread private status. There is one status per
 * 			thread.
 */
static ETAL_dhStatusTy Etal_datahandlerStatus[ETAL_DATA_HANDLERS_NUM];

#ifdef CONFIG_ETAL_CPU_IMPROVEMENT

static OSAL_tEventHandle 	ETAL_datahandler_TaskEventHandler[ETAL_DATA_HANDLERS_NUM];

#endif // CONFIG_ETAL_CPU_IMPROVEMENT

/*****************************************************************
| function prototype definition
|----------------------------------------------------------------*/

static tSInt ETAL_datahandlerFifoPop(ETAL_dhStatusTy *pfifo, ETAL_HANDLE *phDatapath, ETAL_dhMaxSizeTy *param, tU32 *param_size, EtalDataBlockStatusTy *status);

#ifdef CONFIG_ETAL_CPU_IMPROVEMENT
static tVoid ETAL_datahandler_TaskClearEventFlag(tU32 handler_index, tU32 eventFlag);
static tVoid ETAL_datahandler_TaskWakeUpOnEvent (tU32 handler_index, tU32 event);
//static tVoid ETAL_datahandler_TaskWakeUpOnEventFlag (tU32 eventFlag);

tVoid ETAL_datahandler_DataToTx(tU32 handler_index);
tVoid ETAL_datahandler_ProcessData(tU32 handler_index);

#endif


#ifdef CONFIG_ETAL_CPU_IMPROVEMENT
//!
//! \brief      <i><b> tVoid ETAL_datahandler_TaskClearEventFlag (tU32 event) </b></i>
//! \details    Functions to clear possible pending event in the middlewar task on event.
//!           
//! \param[in]  tU32            Event 
//! \return     tVoid           None
//! \sa         n.a.
//! \callgraph
//! \callergraph
//!
static tVoid ETAL_datahandler_TaskClearEventFlag(tU32 handler_index, tU32 eventFlag)
{
	if (handler_index < ETAL_DATA_HANDLERS_NUM)
	{
		ETAL_TaskClearEventFlag(ETAL_datahandler_TaskEventHandler[handler_index], eventFlag);
	}
}

//!
//! \brief      <i><b> ETAL_datahandler_TaskWakeUpOnEvent </b></i>
//! \details    Functions to wake-up the middlewar task on event.
//!             The main loop for the task is waked-up here.
//! \param[in]  tU32            Event 
//! \return     tVoid           None
//! \sa         n.a.
//! \callgraph
//! \callergraph
//!
static tVoid ETAL_datahandler_TaskWakeUpOnEvent (tU32 handler_index, tU32 event)
{
 	if (handler_index < ETAL_DATA_HANDLERS_NUM)
 	{
		if (ETAL_DATAHANDLER_EVENT_TX == event)
		{
			ETAL_TaskWakeUpOnEvent(ETAL_datahandler_TaskEventHandler[handler_index], event);
		}
 	}
}

tVoid ETAL_datahandler_DataToTx(tU32 handler_index)
{
	ETAL_datahandler_TaskWakeUpOnEvent(handler_index, ETAL_DATAHANDLER_EVENT_TX);
}

tVoid ETAL_datahandler_ProcessData(tU32 handler_index)
{

	ETAL_dhStatusTy *pstatus;

	tU32 param_len;
	ETAL_HANDLE hDatapath;
	EtalSink *sinkp;
	EtalDataBlockStatusTy status;
#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_SYSTEM_MIN)
	static tBool warning_issued = FALSE;
#endif

	pstatus = &Etal_datahandlerStatus[handler_index];

	while (ETAL_datahandlerFifoPop(pstatus, &hDatapath, &pstatus->dhStorage, &param_len, &status) == OSAL_OK)
	{
		sinkp = ETAL_receiverDatapathGetSink(hDatapath);
		if (sinkp)
		{
			if (sinkp->m_CbProcessBlock)
			{
				sinkp->m_CbProcessBlock((tU8 *)&pstatus->dhStorage, param_len, &status, sinkp->m_context);
//					ETAL_tracePrintSysmin(TR_CLASS_APP_ETAL, "ETAL_DataHandler_ThreadEntry : callback done datapaht 0x%x, size %d ", hDatapath, param_len);
			}
		}
		else
		{
			/*
			 * the hDatapath is no longer valid; this may legally happen
			 * if the Datapath was removed after the ETAL_datahandlerInvoke
			 */
#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_SYSTEM_MIN)
			if (!warning_issued)
			{
				ETAL_tracePrintSysmin(TR_CLASS_APP_ETAL, "Unknown hDatapath in Datahandler");
				warning_issued = TRUE;
			}
#endif
		}
	}
}		
#endif // CONFIG_ETAL_CPU_IMPROVEMENT



/***************************
 *
 * ETAL_datahandlerFifoReset
 *
 **************************/
static tSInt ETAL_datahandlerFifoReset(ETAL_dhStatusTy *pfifo, tU32 i)
{
	tChar name[ETAL_DATAHANDLER_FIFO_NAME_MAX];
	tSInt ret = OSAL_OK;

	if (OSAL_s32NPrintFormat(name, ETAL_DATAHANDLER_FIFO_NAME_MAX, "%s%u", ETAL_FIFO_DATAHANDLER_BASE_NAME, i) < 0)
	{
		ASSERT_ON_DEBUGGING(0);
		ret = OSAL_ERROR;
	}
	else
	{
		(void)OSAL_pvMemorySet((tVoid *)pfifo->dhFifoStorage, 0x00, sizeof(ETAL_dhFifoElemTy) * ETAL_DATAHANDLER_FIFO_ELEMENTS);
		(void)OSAL_pvMemorySet((tVoid *)&pfifo->dhStorage, 0x00, sizeof(ETAL_dhMaxSizeTy));
		if (COMMON_fifoInit(&pfifo->dhFifo, name, ETAL_DATAHANDLER_FIFO_ELEMENTS) != OSAL_OK)
		{
			ret = OSAL_ERROR;
		}
	}

	return ret;
}

/***************************
 *
 * ETAL_datahandlerFifoPush
 *
 **************************/
/*
 * Pushes a data packet onto the Datahandler FIFO.
 * The data pointed by <param> is copied to a local storage,
 * so <param> can be deallocated after return from this function.
 *
 * Returns:
 *  OSAL_ERROR <param_size> is larger than the max element size, or
 *             the FIFO is full. In both cases the message is discarded.
 *  OSAL_OK
 */
static tSInt ETAL_datahandlerFifoPush(ETAL_dhStatusTy *pfifo, ETAL_HANDLE hDatapath, tVoid *param, tU32 param_size, EtalDataBlockStatusTy *status)
{
	ETAL_dhFifoElemTy *elem;
	tS16 new_write_ptr;
	tSInt ret = OSAL_OK;
	tU8 i;
	
	if (param_size > sizeof(ETAL_dhMaxSizeTy))
	{
		ETAL_tracePrintError(TR_CLASS_APP_ETAL, "Message too long in Datahandler fifo (req %d, max %d)", param_size, sizeof(ETAL_dhMaxSizeTy));
		ret = OSAL_ERROR;
		goto exit;
	}

//	ETAL_tracePrintSystem(TR_CLASS_APP_ETAL, "ETAL_datahandlerFifoPush: IN  0x%x", &pfifo->dhFifo);
		
	COMMON_fifoGetLock(&pfifo->dhFifo);

	if (COMMON_fifoPush(&pfifo->dhFifo, &new_write_ptr) != OSAL_OK)
	{
		// FIFO overflow
		ETAL_tracePrintError(TR_CLASS_APP_ETAL, "Datahandler FIFO overflow");
		// TMP data : print fifo content
		ETAL_tracePrintError(TR_CLASS_APP_ETAL, "Datahandler FIFO overflow read_ptr = %d, write_ptr = %d",
			pfifo->dhFifo.readPtr, pfifo->dhFifo.writePtr);
		
		for (i=0;i<pfifo->dhFifo.fifoSize;i++)
		{
			ETAL_tracePrintError(TR_CLASS_APP_ETAL, "Datahandler FIFO datapath %d", pfifo->dhFifoStorage[i].hDatapath);
		}
		
		COMMON_fifoReleaseLock(&pfifo->dhFifo);
		ret = OSAL_ERROR;
		goto exit;
	}
	elem = &pfifo->dhFifoStorage[new_write_ptr];
	if ((param_size > 0) && (param != NULL))
	{
		(void)OSAL_pvMemoryCopy((tVoid *)&elem->param, (tPCVoid)param, param_size);
	}

	if (status)
	{
		(void)OSAL_pvMemoryCopy((tVoid *)&elem->status, (tPCVoid)status, sizeof(EtalDataBlockStatusTy));
		elem->status.m_isValid = TRUE;
	}
	else
	{
		(void)OSAL_pvMemorySet((tVoid *)&elem->status, 0x00, sizeof(EtalDataBlockStatusTy));
	}
	elem->hDatapath = hDatapath;
	elem->paramSize = param_size;

//#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_COMPONENT)
#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_COMPONENT)
	ETAL_traceDataPath(hDatapath, param, param_size, status);
#endif

//	ETAL_tracePrintSystem(TR_CLASS_APP_ETAL, "ETAL_datahandlerFifoPush: Fifo name %s, read %d, write %d, datapath %x, size %d",
//							pfifo->dhFifo.name, pfifo->dhFifo.readPtr, pfifo->dhFifo.writePtr, hDatapath, param_size );

	COMMON_fifoReleaseLock(&pfifo->dhFifo);

exit:

//	ETAL_tracePrintSystem(TR_CLASS_APP_ETAL, "ETAL_datahandlerFifoPush: OUT  ");
	return ret;
}

/***************************
 *
 * ETAL_datahandlerFifoPop
 *
 **************************/
static tSInt ETAL_datahandlerFifoPop(ETAL_dhStatusTy *pfifo, ETAL_HANDLE *phDatapath, ETAL_dhMaxSizeTy *param, tU32 *param_size, EtalDataBlockStatusTy *status)
{
	tSInt retval = OSAL_OK;
	tU32 size;
	ETAL_dhFifoElemTy *elem;
	tS16 new_read_ptr;

#if 0
#ifndef CONFIG_ETAL_CPU_IMPROVEMENT
	static OSAL_tMSecond vl_mytime = 0;
	OSAL_tMSecond	vl_currentTime;

//	ETAL_tracePrintSystem(TR_CLASS_APP_ETAL, "ETAL_datahandlerFifoPop: IN  0x%x", &pfifo->dhFifo);

	vl_currentTime = OSAL_ClockGetElapsedTime();

	if ((vl_currentTime - vl_mytime) > TMP_MARGIN_SCHEDULING)
	{
		
		ETAL_tracePrintComponent(TR_CLASS_APP_ETAL, "ETAL_datahandlerFifoPop: wrong scheduling %d",	(vl_currentTime - vl_mytime) );
	}
	
	vl_mytime = vl_currentTime;
#endif
#endif

	COMMON_fifoGetLock(&pfifo->dhFifo);
	if (COMMON_fifoPop(&pfifo->dhFifo, &new_read_ptr) != OSAL_OK)
	{
		// FIFO empty condition
		COMMON_fifoReleaseLock(&pfifo->dhFifo);
		retval = OSAL_ERROR;
		goto exit;
		
	}

	elem = &pfifo->dhFifoStorage[new_read_ptr];
	size = elem->paramSize;
	if (size > 0)
	{
		if (size > sizeof(ETAL_dhMaxSizeTy))
		{
			ASSERT_ON_DEBUGGING(0);
			retval = OSAL_ERROR;
		}
		else
		{
			(void)OSAL_pvMemoryCopy((tVoid *)param, (tPCVoid)&elem->param, size);
		}
	}
	*phDatapath = elem->hDatapath;
	*param_size = size;
	(void)OSAL_pvMemoryCopy((tVoid *)status, (tPCVoid)&elem->status, sizeof(EtalDataBlockStatusTy));

//	ETAL_tracePrintSystem(TR_CLASS_APP_ETAL, "ETAL_datahandlerFifoPop: Fifo name %s, read %d, write %d, datapath %x, size %d",
//							pfifo->dhFifo.name, pfifo->dhFifo.readPtr, pfifo->dhFifo.writePtr, elem->hDatapath, size);

	COMMON_fifoReleaseLock(&pfifo->dhFifo);

exit:
//	ETAL_tracePrintSystem(TR_CLASS_APP_ETAL, "ETAL_datahandlerFifoPop: OUT  ");
	return retval;
}

/***************************
 *
 * ETAL_datahandlerInit
 *
 **************************/
/*!
 * \brief		Initializes the Datahandler storage
 * \return		OSAL_OK
 * \callgraph
 * \callergraph
 */
tSInt ETAL_datahandlerInit(tVoid)
{
	tU32 i;
	tSInt ret = OSAL_OK;
#ifdef CONFIG_ETAL_CPU_IMPROVEMENT
	tChar name[ETAL_EVENT_BASE_NAME_MAX_LEN];
#endif

	for (i = 0; i < ETAL_DATA_HANDLERS_NUM; i++)
	{
		if (ETAL_datahandlerFifoReset(&Etal_datahandlerStatus[i], i) != OSAL_OK)
		{
			ret = OSAL_ERROR;
			goto exit;
		}
	}

#ifdef CONFIG_ETAL_CPU_IMPROVEMENT
	for (i = 0; i < ETAL_DATA_HANDLERS_NUM; i++)
	{
		if (OSAL_s32NPrintFormat(name, ETAL_EVENT_BASE_NAME_MAX_LEN, "%s%d", ETAL_EVENT_HANDLER_DATAHANDLER_BASE_NAME, i) < 0)
		{
			ret = OSAL_ERROR;
			goto exit;
		}
		// Init globals
		ETAL_datahandler_TaskEventHandler[i] = (OSAL_tEventHandle)0;
		OSAL_s32EventCreate ((tCString)name, &ETAL_datahandler_TaskEventHandler[i]);	
	}
#endif //  CONFIG_ETAL_CPU_IMPROVEMENT


exit:
	return ret;
}

/***************************
 *
 * ETAL_datahandlerDeinit
 *
 **************************/
/*!
 * \brief		De-initializes the Datahandler storage
 * \details		Mainly destroys the semaphores created for the FIFO.
 * \return		OSAL_OK
 * \callgraph
 * \callergraph
 */
tSInt ETAL_datahandlerDeinit(tVoid)
{
	tSInt ret = OSAL_OK;
	tU32 i;
	tChar name[ETAL_DATAHANDLER_FIFO_NAME_MAX];

#ifdef CONFIG_ETAL_CPU_IMPROVEMENT
	tChar name2[ETAL_EVENT_BASE_NAME_MAX_LEN];
#endif

	for (i = 0; i < ETAL_DATA_HANDLERS_NUM; i++)
	{
		if (OSAL_s32NPrintFormat(name, ETAL_DATAHANDLER_FIFO_NAME_MAX, "%s%u", ETAL_FIFO_DATAHANDLER_BASE_NAME, i) < 0)
		{
			ASSERT_ON_DEBUGGING(0);
			ret = OSAL_ERROR;
			goto exit;
		}
		else
		{
			COMMON_fifoDeinit(&Etal_datahandlerStatus[i].dhFifo, name);
		}
	}


#ifdef CONFIG_ETAL_CPU_IMPROVEMENT


	for (i = 0; i < ETAL_DATA_HANDLERS_NUM; i++)
	{	
#ifndef OSAL_EVENT_SKIP_NAMES
		if (OSAL_s32EventClose(ETAL_datahandler_TaskEventHandler[i]) != OSAL_OK)
		{
			ret = OSAL_ERROR;
			goto exit;
		}
		
		OSAL_s32ThreadWait(100);
		if (OSAL_s32NPrintFormat(name2, ETAL_EVENT_BASE_NAME_MAX_LEN, "%s%d", ETAL_EVENT_HANDLER_DATAHANDLER_BASE_NAME, i) < 0)
		{
			ret = OSAL_ERROR;
			goto exit;
		}
		
		if (OSAL_s32EventDelete(name2) != OSAL_OK)
		{
			ret = OSAL_ERROR;
			goto exit;
		}
#else
		if (OSAL_s32EventFree(ETAL_datahandler_TaskEventHandler[i]) != OSAL_OK)
		{
			ret = OSAL_ERROR;
			goto exit;
		}
#endif
	
		ETAL_datahandler_TaskEventHandler[i] = (OSAL_tEventHandle)0;
	}
#endif // CONFIG_ETAL_CPU_IMPROVEMENT

exit:

	return ret;
}

/***************************
 *
 * ETAL_datahandlerInvoke
 *
 **************************/
/*!
 * \brief		Indirectly invokes the Datapath sink
 * \details		Function called by all ETAL API functions to indirectly
 * 				invoke the Datapath sink function provided by the ETAL API user.
 * 				Puts the data into a FIFO processed by the Datahandler thread.
 * 				The Datahandler thread then calls the appropriate sink
 * 				depending on the Datapath.
 *
 * 				The *param* data buffer is copied to a Datahandler local storage
 * 				so the caller can re-use it after this function returns.
 *
 * 				The functions support multiple Datapath handlers.
 * \param[in]	handler_index - ranges 0..#ETAL_DATA_HANDLERS_NUM and indicates
 * 				                which handler to use
 * \param[in]	hDatapath     - The Datapath handle, will be used to decide which sink to invoke
 * \param[in]	param         - The data passed to the sink function
 * \param[in]	param_len     - The size in bytes of *param*
 * \param[in]	status        - The status of the data contained in *param*
 * \return		OSAL_OK    - the data was delivered without errors
 * \return		OSAL_ERROR - the FIFO is full, the data was discarded
 * \callgraph
 * \callergraph
 */
tSInt ETAL_datahandlerInvoke(tU32 handler_index, ETAL_HANDLE hDatapath, tVoid *param, tU32 param_len, EtalDataBlockStatusTy *status)
{
	tSInt ret;
	
	if (handler_index >= ETAL_DATA_HANDLERS_NUM)
	{
		ASSERT_ON_DEBUGGING(0);
		ret = OSAL_ERROR;
	}
	else if (ETAL_datahandlerFifoPush(&Etal_datahandlerStatus[handler_index], hDatapath, param, param_len, status) == OSAL_ERROR)
	{
		ret = OSAL_ERROR;
	}
	else
	{
#ifdef CONFIG_ETAL_CPU_IMPROVEMENT
		ETAL_datahandler_DataToTx(handler_index);
#endif
		ret = OSAL_OK;
	}

	return ret;
}

/***************************
 *
 * ETAL_DataHandler_ThreadEntry
 *
 **************************/
/*!
 * \brief		Datahandler Thread main entry point
 * \details		Implements the Datahandler Thread. The thread endlessly tries to
 * 				pop a value from the Datahandler FIFO, invokes the sink and sleeps.
 * 				Sinks are invoked this way rather than directly from ETAL internals
 * 				to avoid locking up the whole ETAL in case of misbehaving user sink.
 *
 * 				It is possible to spawn more than one Datahandler, provided each
 * 				one is initialized with unique *thread_param* value. This feature is
 * 				implemented but not tested.
 * \remark		The function does not perform any check on the user sink duration.
 * 				It is up to the user to avoid locking up the Datahandler mechanism for too long.
 * \param[in]	thread_param - interpreted as the Datahandler index. The function
 * 				               uses this parameter to access its private storage (required
 * 				               in case more than one Datahandler thread is spawned).
 * \callgraph
 * \callergraph
 */
#ifdef CONFIG_HOST_OS_TKERNEL
tVoid ETAL_DataHandler_ThreadEntry(tSInt stacd, tPVoid thread_param)
#else
tVoid ETAL_DataHandler_ThreadEntry(tPVoid thread_param)
#endif
{
	tU32 thread_index;

#ifndef CONFIG_ETAL_CPU_IMPROVEMENT
	ETAL_dhStatusTy *pstatus;
	tU32 param_len;
	ETAL_HANDLE hDatapath;
	EtalSink *sinkp;
	EtalDataBlockStatusTy status;
#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_SYSTEM_MIN)
	static tBool warning_issued = FALSE;
#endif
#endif



#ifdef CONFIG_ETAL_CPU_IMPROVEMENT
		tSInt vl_res;
		OSAL_tEventMask vl_resEvent = ETAL_DATAHANDLER_NO_EVENT_FLAG;
#endif //CONFIG_ETAL_CPU_IMPROVEMENT


	thread_index = (tU32)((tULong)thread_param);
	if (thread_index >= ETAL_DATA_HANDLERS_NUM)
	{
		ASSERT_ON_DEBUGGING(0);
		goto exit;
	}

#ifdef CONFIG_ETAL_CPU_IMPROVEMENT

	while (TRUE)
	{
		vl_res = OSAL_s32EventWait (ETAL_datahandler_TaskEventHandler[thread_index],
								 ETAL_DATAHANDLER_EVENT_WAIT_ALL, 
								 OSAL_EN_EVENTMASK_OR, 
								 ETAL_DATAHANDLER_EVENT_WAIT_TIME_MS,
								 &vl_resEvent);
		
		ETAL_tracePrintUser1(TR_CLASS_APP_ETAL_COMM, "ETAL_DataHandler_ThreadEntry: Index %d, scheduling event vl_res = %d, vl_resEvent = 0x%x",
				thread_index, vl_res, vl_resEvent);

		if (OSAL_ERROR == vl_res)
		{
			// Event wait failure ==> break;
			
			ETAL_tracePrintError(TR_CLASS_APP_ETAL_COMM, "ETAL_IRQ_ThreadEntry: wait error");
			break;
		}
		else if ((vl_resEvent == ETAL_DATAHANDLER_NO_EVENT_FLAG) || (OSAL_ERROR_TIMEOUT_EXPIRED == vl_res))
		{
			// this is a timeout : no even received
			// trigger the SF task normal processing
		}
		else if (OSAL_OK == vl_res)
		{
			// This is a ETAL_COMM_MDR_EVENT_DATA_TO_TX_FLAG call the Tx event handler
			if (ETAL_DATAHANDLER_EVENT_TX_FLAG == (ETAL_DATAHANDLER_EVENT_TX_FLAG & vl_resEvent))
			{			
				// clear event now that it will be processed
				ETAL_datahandler_TaskClearEventFlag(thread_index, ETAL_DATAHANDLER_EVENT_TX_FLAG);
				// process
				ETAL_datahandler_ProcessData(thread_index);
			}
			
			// unexepected event case
			if (!(ETAL_DATAHANDLER_EVENT_WAIT_MASK & vl_resEvent))
			{
				// just clear the event
				ETAL_datahandler_TaskClearEventFlag(thread_index, vl_resEvent);
			}
			
		}
		else
		{
			// should not come here all processed already
		}

	}
#else // CONFIG_ETAL_CPU_IMPROVEMENT

	pstatus = &Etal_datahandlerStatus[thread_index];

	while (TRUE)
	{
		while (ETAL_datahandlerFifoPop(pstatus, &hDatapath, &pstatus->dhStorage, &param_len, &status) == OSAL_OK)
		{
			sinkp = ETAL_receiverDatapathGetSink(hDatapath);
			if (sinkp)
			{
				if (sinkp->m_CbProcessBlock)
				{
					sinkp->m_CbProcessBlock((tU8 *)&pstatus->dhStorage, param_len, &status, sinkp->m_context);

//					ETAL_tracePrintSysmin(TR_CLASS_APP_ETAL, "ETAL_DataHandler_ThreadEntry : callback done datapaht 0x%x, size %d ", hDatapath, param_len);
				}
			}
			else
			{
				/*
				 * the hDatapath is no longer valid; this may legally happen
				 * if the Datapath was removed after the ETAL_datahandlerInvoke
				 */
#if defined(CONFIG_TRACE_CLASS_ETAL) && (CONFIG_TRACE_CLASS_ETAL >= TR_LEVEL_SYSTEM_MIN)
				if (!warning_issued)
				{
					ETAL_tracePrintSysmin(TR_CLASS_APP_ETAL, "Unknown hDatapath in Datahandler");
					warning_issued = TRUE;
				}
#endif
			}
		}
		(void)OSAL_s32ThreadWait(ETAL_DATAHANDLER_THREAD_SCHEDULING);
	}
#endif 

exit:
	return;
}
