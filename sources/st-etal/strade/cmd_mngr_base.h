#ifndef CMD_MNGR_BASE_H
#define CMD_MNGR_BASE_H

#include "common.h"

enum Mode   { FM = 0, DAB = 1, AM = 2, DRM = 3, HD = 4, IDLE = 5, MODE_MAX = 3 };

enum Band   { B_AM, B_FM, B_DAB3, B_SW, B_MW, B_LW, B_DRM30, B_DRM_PLUS };

struct fmQualityInfoTy
{
    quint8 qualDetune;      // Detune 8bit unsigned FM(AM,WX) 0xFF=50kHz(5kHz,10kHz) resol 195Hz(19.5Hz,39Hz)
    quint8 qualMultiPath;   // Multipath 8bit unsigned 0xFF=100% resolution=0.39%
    quint8 qualMpxNoise;    // MPX Noise 8bit usigned 0xFF= 100%
    quint8 qualSNR;         // SNR log scale 8bit unsigned 0x00=0SNR  0xFF=MaxSNR
    quint8 qualAdj;         // Adjacent Channel 8bit signed 0x80=NoAdj 0x7F=Adj>>desired 0x00= Adj=desired
    quint8 qualCoChannel;   // FM VPA Co-Channel 8bit unsigned 0xFF = 100% resol. 0.39%
    quint8 qualDeviation;   // Deviation  7bit unsigned 0x7F=200kHz resolution 1.6kHz
    quint8 qualStereo;      // Bit Stereo  (1=Stereo 0=Mono)
};

struct dabQualityInfoTy
{
    quint8 qualDabTxMode;       // Dab Trasmission Mode (autoNotify)
    QString ensembleChannel;    // Current DAB Ensemble Channel Number
    quint8 serviceSubCh;        // Service Sub Channel (from Service Select)
    quint8 serviceComponent;    // Service Component (from Service Select)
    quint8 qualServiceBitRate;  // Service Bit Rate (from Service Select)
    quint32 ficBer;             // Fic Ber value
    quint32 mscBer;             // MSC Ber value
    quint32 audioBer;           // Audio Ber value
    quint8  audioCRCError;      // Quality Audio CRC Error samples
    quint8  audioCRCTotal;      // Quality Audio CRC Total samples
    quint8 baseband_level;      // Quality BaseBand Level indicator
};

struct qualityInfoTy
{
    bool   sync;                // To check if the signal is present (i.e "No signal" display)
    quint8 syncLevel;           // To check if the signal is present - for seek mainly
    quint8 qualFicBer;          // FicBer Dab (used also for signal quality icon update)
    quint8 qualFstRf;           // Smeter RF level ( used also for quality icon update) 8bit signed
    quint8 qualFstBb;           // Smeter BaseBand level 8bit signed

    fmQualityInfoTy fmQualityInfo;
    dabQualityInfoTy dabQualityInfo;
};

enum slsPtyRenderSize
{
    IMAGE_RENDER_SIZE_NORMAL    = 0, // Image will be displayed in normal size
    IMAGE_RENDER_SIZE_SMALL     = 1, // Image will be displayed as thumbnail
    IMAGE_RENDER_SIZE_BIG       = 2  // Image will be displayed to use all available space
};

enum eventsList
{
    // Events generated from device
    EVENTS_NO_EVENT                             = 0x00, //!< Placeholder for no events generated
    EVENTS_RX_FREQ                              = 0x01,
    EVENTS_RX_ENSEMBLE_NAME                     = 0x02,
    EVENTS_RX_SERVICE_LIST                      = 0x03,
    EVENTS_RX_SERVICE_NAME                      = 0x04,
    EVENTS_RX_DLS                               = 0x05,
    EVENTS_RX_SLS                               = 0x06,
    EVENTS_RX_SERVICESEL                        = 0x07,
    EVENTS_RX_SYNC_LEVEL                        = 0x08,
    EVENTS_RX_QUALITY_LEVEL                     = 0x09,
    EVENTS_RX_PING                              = 0x0A,
    EVENTS_RX_RDS_BLOCKS                        = 0x0B,

    // Internal events
    EVENTS_UPDATE_SERVICE_LIST                  = 0x20,
    EVENTS_UPDATE_RDS_DATA                      = 0x21,
    EVENTS_UPDATE_AUDIO_PLAYS                   = 0x22,

    // Collector
    EVENTS_GENERIC                              = 0xFF  //!< Placeholder to trigger any event
};

struct eventDataInterface
{
    eventsList eventType;      //!< Event type
    int size;                       //!< Size of the data contained in the 'dataPtr' field
    unsigned char* dataPtr;         //!< Data pointer (here is contained the event data when not requiring a specific structure, i.e. DLS)
};

#if 0
static const unsigned short ebuLatin1ToUcs2 [] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    0x20, 0x21, 0x22, 0x23, 0xA4, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,  //5
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,  //7
    0xE1, 0xE0, 0xE9, 0xE8, 0xED, 0xEC, 0xF3, 0xF2, 0xFA, 0xF9, 0xD1, 0xC7, 0x15E, 0xDF, 0xA1, 0x132,  //8
    0xE2, 0xE4, 0xEA, 0xEB, 0xEE, 0xEF, 0xF4, 0xF6, 0xFB, 0xFC, 0xF1, 0xE7, 0x15F, 0x11F, 0x3F, 0x133,  // 3F = ? means char not found in Unicode
    0xAA, 0x3B1, 0xA9, 0x2030, 0x11E, 0x11B, 0x148, 0x151, 0x3C0, 0x3F, 0xA3, 0x24, 0x2190, 0x2191, 0x2192, 0x2193,  //a
    0xBA, 0xB9, 0xB2, 0xB3, 0xB1, 0x130, 0x144, 0x171, 0x3BC, 0xBF, 0xF7, 0xB0, 0xBC, 0xBD, 0xBE, 0xA7,
    0xC1, 0xC0, 0xC9, 0xC8, 0xCD, 0xCC, 0xD3, 0xD2, 0xDA, 0xD9, 0x158, 0x10C, 0x160, 0x17D, 0x110, 0x3F,  //c
    0xC2, 0xC4, 0xCA, 0xCB, 0xCE, 0xCF, 0xD4, 0xD6, 0xDB, 0xDC, 0x159, 0x10D, 0x161, 0x17E, 0x111, 0x3F,
    0xC3, 0xC5, 0xC6, 0x152, 0x177, 0xDD, 0xD5, 0xD8, 0xDE, 0x3F, 0x154, 0x106, 0x15A, 0x179, 0x2213, 0x3F,  //e
    0xE3, 0xE5, 0xE6, 0x153, 0x175, 0xFD, 0xF5, 0xF8, 0xFE, 0x3F, 0x155, 0x107, 0x15B, 0x17A, 0x3F, 0x3F
};

static const unsigned short ebuLatinToUcs2 [] =
{
    /* 0x00 - 0x07 */ 0x00,   0x0118, 0x012e, 0x0172, 0x0102, 0x0116, 0x010e, 0x0218,
    /* 0x08 - 0x0f */ 0x021a, 0x010a, 0x0a,   0x0b,   0x0120, 0x0139, 0x017b, 0x0143,
    /* 0x10 - 0x17 */ 0x0105, 0x0119, 0x012f, 0x0173, 0x0103, 0x0117, 0x010f, 0x0219,
    /* 0x18 - 0x1f */ 0x021b, 0x010b, 0x0147, 0x011a, 0x0121, 0x013a, 0x017c, 0x1f,

    /* 0x20 - 0x27 */ 0x20,   0x21,   0x22,   0x23,   0x0142, 0x25,   0x26,   0x27,
    /* 0x28 - 0x2f */ 0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f,
    /* 0x30 - 0x37 */ 0x30,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,
    /* 0x38 - 0x3f */ 0x38,   0x39,   0x3a,   0x3b,   0x3c,   0x3d,   0x3e,   0x3f,
    /* 0x40 - 0x47 */ 0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
    /* 0x48 - 0x4f */ 0x48,   0x49,   0x4a,   0x4b,   0x4c,   0x4d,   0x4e,   0x4f,
    /* 0x50 - 0x57 */ 0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,
    /* 0x58 - 0x5f */ 0x58,   0x59,   0x5a,   0x5b,   0x016e, 0x5d,   0x0141, 0x5f,
    /* 0x60 - 0x67 */ 0x0104, 0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,
    /* 0x68 - 0x6f */ 0x68,   0x69,   0x6a,   0x6b,   0x6c,   0x6d,   0x6e,   0x6f,
    /* 0x70 - 0x77 */ 0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,
    /* 0x78 - 0x7f */ 0x78,   0x79,   0x7a,   0x00ab, 0x016f, 0x00bb, 0x013d, 0x0126,

    /* 0x80 - 0x87 */ 0xe1,   0xe0,   0xe9,   0xe8,   0xed,   0xec,   0xf3,   0xf2,
    /* 0x88 - 0x8f */ 0xfa,   0xf9,   0xd1,   0xc7,   0x015e, 0xdf,   0xa1,   0x0132,
    /* 0x90 - 0x97 */ 0xe2,   0xe4,   0xea,   0xeb,   0xee,   0xef,   0xf4,   0xf6,
    /* 0x98 - 0x9f */ 0xfb,   0xfc,   0xf1,   0xe7,   0x015f, 0x011f, 0x0131, 0x0133,
    /* 0xa0 - 0xa7 */ 0xaa,   0x03b1, 0xa9,   0x2030, 0x011e, 0x011b, 0x0148, 0x0151,
    /* 0xa8 - 0xaf */ 0x03c0, 0x20ac, 0xa3,   0x24,   0x2190, 0x2191, 0x2192, 0x2193,
    /* 0xb0 - 0xb7 */ 0xba,   0xb9,   0xb2,   0xb3,   0xb1,   0x0130, 0x0144, 0x0171,
    /* 0xb8 - 0xbf */ 0xb5,   0xbf,   0xf7,   0xb0,   0xbc,   0xbd,   0xbe,   0xa7,
    /* 0xc0 - 0xc7 */ 0xc1,   0xc0,   0xc9,   0xc8,   0xcd,   0xcc,   0xd3,   0xd2,
    /* 0xc8 - 0xcf */ 0xda,   0xd9,   0x0158, 0x010c, 0x0160, 0x017d, 0xd0,   0x13f,
    /* 0xd0 - 0xd7 */ 0xc2,   0xc4,   0xca,   0xcb,   0xce,   0xcf,   0xd4,   0xd6,
    /* 0xd8 - 0xdf */ 0xdb,   0xdc,   0x0159, 0x010d, 0x0161, 0x017e, 0x0111, 0x0140,
    /* 0xe0 - 0xe7 */ 0x00c3, 0x00c5, 0x00c6, 0x0152, 0x0177, 0xdd,   0xd5,   0xd8,
    /* 0xe8 - 0xef */ 0xde,   0x014a, 0x0154, 0x0106, 0x015a, 0x0179, 0x0166, 0xf0,
    /* 0xf0 - 0xf7 */ 0xe3,   0xe5,   0xe6,   0x0153, 0x0175, 0xfd,   0xf5,   0xf8,
    /* 0xf8 - 0xff */ 0xfe,   0x014b, 0x0155, 0x0107, 0x015b, 0x017a, 0x0167, 0xff
};
#endif

class CmdMngrBase
{
    public:
        QString toQStringUsingCharset(const char* buffer, quint8 charset, qint32 size)
        {
            const unsigned short ebuLatinToUcs2 [] =
            {
                /* 0x00 - 0x07 */ 0x00,   0x0118, 0x012e, 0x0172, 0x0102, 0x0116, 0x010e, 0x0218,
                /* 0x08 - 0x0f */ 0x021a, 0x010a, 0x0a,   0x0b,   0x0120, 0x0139, 0x017b, 0x0143,
                /* 0x10 - 0x17 */ 0x0105, 0x0119, 0x012f, 0x0173, 0x0103, 0x0117, 0x010f, 0x0219,
                /* 0x18 - 0x1f */ 0x021b, 0x010b, 0x0147, 0x011a, 0x0121, 0x013a, 0x017c, 0x1f,

                /* 0x20 - 0x27 */ 0x20,   0x21,   0x22,   0x23,   0x0142, 0x25,   0x26,   0x27,
                /* 0x28 - 0x2f */ 0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f,
                /* 0x30 - 0x37 */ 0x30,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,
                /* 0x38 - 0x3f */ 0x38,   0x39,   0x3a,   0x3b,   0x3c,   0x3d,   0x3e,   0x3f,
                /* 0x40 - 0x47 */ 0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
                /* 0x48 - 0x4f */ 0x48,   0x49,   0x4a,   0x4b,   0x4c,   0x4d,   0x4e,   0x4f,
                /* 0x50 - 0x57 */ 0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,
                /* 0x58 - 0x5f */ 0x58,   0x59,   0x5a,   0x5b,   0x016e, 0x5d,   0x0141, 0x5f,
                /* 0x60 - 0x67 */ 0x0104, 0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,
                /* 0x68 - 0x6f */ 0x68,   0x69,   0x6a,   0x6b,   0x6c,   0x6d,   0x6e,   0x6f,
                /* 0x70 - 0x77 */ 0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,
                /* 0x78 - 0x7f */ 0x78,   0x79,   0x7a,   0x00ab, 0x016f, 0x00bb, 0x013d, 0x0126,

                /* 0x80 - 0x87 */ 0xe1,   0xe0,   0xe9,   0xe8,   0xed,   0xec,   0xf3,   0xf2,
                /* 0x88 - 0x8f */ 0xfa,   0xf9,   0xd1,   0xc7,   0x015e, 0xdf,   0xa1,   0x0132,
                /* 0x90 - 0x97 */ 0xe2,   0xe4,   0xea,   0xeb,   0xee,   0xef,   0xf4,   0xf6,
                /* 0x98 - 0x9f */ 0xfb,   0xfc,   0xf1,   0xe7,   0x015f, 0x011f, 0x0131, 0x0133,
                /* 0xa0 - 0xa7 */ 0xaa,   0x03b1, 0xa9,   0x2030, 0x011e, 0x011b, 0x0148, 0x0151,
                /* 0xa8 - 0xaf */ 0x03c0, 0x20ac, 0xa3,   0x24,   0x2190, 0x2191, 0x2192, 0x2193,
                /* 0xb0 - 0xb7 */ 0xba,   0xb9,   0xb2,   0xb3,   0xb1,   0x0130, 0x0144, 0x0171,
                /* 0xb8 - 0xbf */ 0xb5,   0xbf,   0xf7,   0xb0,   0xbc,   0xbd,   0xbe,   0xa7,
                /* 0xc0 - 0xc7 */ 0xc1,   0xc0,   0xc9,   0xc8,   0xcd,   0xcc,   0xd3,   0xd2,
                /* 0xc8 - 0xcf */ 0xda,   0xd9,   0x0158, 0x010c, 0x0160, 0x017d, 0xd0,   0x13f,
                /* 0xd0 - 0xd7 */ 0xc2,   0xc4,   0xca,   0xcb,   0xce,   0xcf,   0xd4,   0xd6,
                /* 0xd8 - 0xdf */ 0xdb,   0xdc,   0x0159, 0x010d, 0x0161, 0x017e, 0x0111, 0x0140,
                /* 0xe0 - 0xe7 */ 0x00c3, 0x00c5, 0x00c6, 0x0152, 0x0177, 0xdd,   0xd5,   0xd8,
                /* 0xe8 - 0xef */ 0xde,   0x014a, 0x0154, 0x0106, 0x015a, 0x0179, 0x0166, 0xf0,
                /* 0xf0 - 0xf7 */ 0xe3,   0xe5,   0xe6,   0x0153, 0x0175, 0xfd,   0xf5,   0xf8,
                /* 0xf8 - 0xff */ 0xfe,   0x014b, 0x0155, 0x0107, 0x015b, 0x017a, 0x0167, 0xff
            };

            QString s;
            uint16_t length = 0;
            uint16_t i;

            if (size == -1)
            {
                length = strlen(buffer);
            }
            else
            {
                length = size;
            }

            switch (charset)
            {
                case 0x06:
                    s = QString::fromUtf16((const ushort *)buffer, length);
                    break;

                case 0x0f:
                    s = QString::fromUtf8(buffer, length);
                    break;

                case 0x00:
                default:
                    s = QString();

                    for (i = 0; i < length; i++)
                    {
                        s [i] = QChar(ebuLatinToUcs2 [((uint8_t *)buffer)[i]]);
                    }
            }

            return s;
        }

        virtual void seekHandler(void* status) = 0;
};

#endif // CMD_MNGR_BASE_H
